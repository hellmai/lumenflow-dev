---
title: Port Interfaces
description: Hexagonal architecture ports for context-aware validation
---

LumenFlow uses hexagonal architecture with port interfaces to enable dependency injection and testing. External users can inject custom implementations.

## Context Ports

### ILocationResolver

Resolves the current working directory context to determine main checkout vs worktree.

```typescript
import type { ILocationResolver } from '@lumenflow/core';
import { resolveLocation, LocationType } from '@lumenflow/core';

// Default implementation
const resolver: ILocationResolver = { resolveLocation };

// Custom implementation for testing
const mockResolver: ILocationResolver = {
  resolveLocation: async (cwd) => ({
    type: LocationType.MAIN,
    cwd: cwd || '/repo',
    gitRoot: '/repo',
    mainCheckout: '/repo',
    worktreeName: null,
    worktreeWuId: null,
  }),
};
```

**Method**: `resolveLocation(cwd?: string): Promise<LocationContext>`

Returns:

- `type`: `LocationType.MAIN` | `LocationType.WORKTREE` | `LocationType.DETACHED` | `LocationType.UNKNOWN`
- `cwd`: Absolute path to current working directory
- `gitRoot`: Git root (top-level of working tree)
- `mainCheckout`: Path to main checkout (primary repo)
- `worktreeName`: Worktree name if in worktree (e.g., `'framework-core-wu-1090'`)
- `worktreeWuId`: WU ID extracted from worktree (e.g., `'WU-1090'`)

### IGitStateReader

Reads current git state including branch, dirty status, and ahead/behind counts.

```typescript
import type { IGitStateReader } from '@lumenflow/core';
import { readGitState } from '@lumenflow/core';

// Default implementation
const reader: IGitStateReader = { readGitState };

// Custom implementation for testing
const mockReader: IGitStateReader = {
  readGitState: async () => ({
    branch: 'main',
    isDetached: false,
    isDirty: false,
    hasStaged: false,
    ahead: 0,
    behind: 0,
    tracking: 'origin/main',
    modifiedFiles: [],
    hasError: false,
    errorMessage: null,
  }),
};
```

**Method**: `readGitState(cwd?: string): Promise<GitState>`

Returns:

- `branch`: Current branch name (null if detached)
- `isDetached`: Whether HEAD is detached
- `isDirty`: Working tree has uncommitted changes
- `hasStaged`: Has staged changes
- `ahead`: Commits ahead of tracking branch
- `behind`: Commits behind tracking branch
- `tracking`: Tracking branch (e.g., `'origin/main'`)
- `modifiedFiles`: List of modified files
- `hasError`: Whether an error occurred
- `errorMessage`: Error message if applicable

### IWuStateReader

Reads WU state from YAML file and cross-references with state store.

```typescript
import type { IWuStateReader } from '@lumenflow/core';
import { readWuState } from '@lumenflow/core';

// Default implementation
const reader: IWuStateReader = { readWuState };

// Custom implementation for testing
const mockReader: IWuStateReader = {
  readWuState: async (wuId, repoRoot) => ({
    id: wuId,
    status: 'in_progress',
    lane: 'Framework: Core',
    title: 'Test WU',
    yamlPath: `${repoRoot}/docs/04-operations/tasks/wu/${wuId}.yaml`,
    isConsistent: true,
    inconsistencyReason: null,
  }),
};
```

**Method**: `readWuState(wuId: string, repoRoot: string): Promise<WuStateResult | null>`

Returns:

- `id`: WU ID (uppercase)
- `status`: Current status from YAML
- `lane`: Lane name
- `title`: WU title
- `yamlPath`: Absolute path to WU YAML file
- `isConsistent`: Whether YAML and state store agree
- `inconsistencyReason`: Reason if inconsistent

## Validation Ports

### ICommandRegistry

Provides command definitions and validation logic for wu:\* commands.

```typescript
import type { ICommandRegistry } from '@lumenflow/core';
import {
  getCommandDefinition,
  getValidCommandsForContext,
  COMMAND_REGISTRY,
} from '@lumenflow/core';

// Default implementation
const registry: ICommandRegistry = {
  getCommandDefinition,
  getValidCommandsForContext,
  getAllCommands: () => Array.from(COMMAND_REGISTRY.values()),
};
```

**Methods**:

- `getCommandDefinition(command: string): CommandDefinition | null`
- `getValidCommandsForContext(context: WuContext): CommandDefinition[]`
- `getAllCommands(): CommandDefinition[]`

## Recovery Ports

### IRecoveryAnalyzer

Analyzes WU context to detect state inconsistencies and suggest recovery actions.

```typescript
import type { IRecoveryAnalyzer } from '@lumenflow/core';
import { analyzeRecovery } from '@lumenflow/core';

// Default implementation
const analyzer: IRecoveryAnalyzer = { analyzeRecovery };

// Custom implementation for testing
const mockAnalyzer: IRecoveryAnalyzer = {
  analyzeRecovery: async (context) => ({
    hasIssues: false,
    issues: [],
    actions: [],
    wuId: context.wu?.id ?? null,
  }),
};
```

**Method**: `analyzeRecovery(context: WuContext): Promise<RecoveryAnalysis>`

Returns:

- `hasIssues`: Whether any issues were found
- `issues`: Array of `RecoveryIssue` objects
- `actions`: Array of suggested `RecoveryAction` objects
- `wuId`: WU ID analyzed

Issue codes (use `RecoveryIssueCode` enum):

- `RecoveryIssueCode.PARTIAL_CLAIM`: Worktree exists but status is ready
- `RecoveryIssueCode.ORPHAN_CLAIM`: Status is in_progress but worktree missing
- `RecoveryIssueCode.INCONSISTENT_STATE`: YAML and state store disagree
- `RecoveryIssueCode.ORPHAN_BRANCH`: Branch exists but worktree missing
- `RecoveryIssueCode.STALE_LOCK`: Lock file from old session
- `RecoveryIssueCode.LEFTOVER_WORKTREE`: WU is done but worktree exists

Action types (use `RecoveryActionType` enum):

- `RecoveryActionType.RESUME`: Reconcile state and continue (preserves work)
- `RecoveryActionType.RESET`: Discard worktree, reset to ready
- `RecoveryActionType.NUKE`: Remove all artifacts (requires --force)
- `RecoveryActionType.CLEANUP`: Remove leftover worktree

## Exported Constants

To avoid magic string literals in code, use the exported enum-style constants:

### LocationType

```typescript
import { LocationType } from '@lumenflow/core';

// Use constants instead of string literals
if (location.type === LocationType.MAIN) {
  // In main checkout
} else if (location.type === LocationType.WORKTREE) {
  // In a worktree
}

// Available values:
// LocationType.MAIN      - 'main'
// LocationType.WORKTREE  - 'worktree'
// LocationType.DETACHED  - 'detached'
// LocationType.UNKNOWN   - 'unknown'
```

### RecoveryIssueCode

```typescript
import { RecoveryIssueCode } from '@lumenflow/core';

// Check issue codes
if (issue.code === RecoveryIssueCode.PARTIAL_CLAIM) {
  // Handle partial claim
}

// Available values:
// RecoveryIssueCode.PARTIAL_CLAIM      - Worktree exists but status is ready
// RecoveryIssueCode.ORPHAN_CLAIM       - Status is in_progress but worktree missing
// RecoveryIssueCode.INCONSISTENT_STATE - YAML and state store disagree
// RecoveryIssueCode.ORPHAN_BRANCH      - Branch exists but worktree missing
// RecoveryIssueCode.STALE_LOCK         - Lock file from old session
// RecoveryIssueCode.LEFTOVER_WORKTREE  - WU is done but worktree exists
```

### RecoveryActionType

```typescript
import { RecoveryActionType } from '@lumenflow/core';

// Check action types
if (action.type === RecoveryActionType.RESUME) {
  // Resume the WU
}

// Available values:
// RecoveryActionType.RESUME  - Reconcile state and continue (preserves work)
// RecoveryActionType.RESET   - Discard worktree, reset to ready
// RecoveryActionType.NUKE    - Remove all artifacts (requires --force)
// RecoveryActionType.CLEANUP - Remove leftover worktree
```

## Domain Schemas

All domain types have corresponding Zod schemas for runtime validation.

```typescript
import {
  LocationContextSchema,
  GitStateSchema,
  WuStateResultSchema,
  ValidationErrorSchema,
  RecoveryAnalysisSchema,
} from '@lumenflow/core';

// Validate runtime data
const result = LocationContextSchema.safeParse(unknownData);
if (result.success) {
  const location = result.data; // Type: LocationContext
}
```

See `@lumenflow/core` package exports for all available schemas and types.

## Adapter Classes

WU-1094 introduces concrete adapter implementations that wrap the existing functions:

### Context Adapters

```typescript
import {
  SimpleGitLocationAdapter,
  SimpleGitStateAdapter,
  FileSystemWuStateAdapter,
} from '@lumenflow/core';

// Create adapters implementing port interfaces
const locationResolver = new SimpleGitLocationAdapter();
const gitStateReader = new SimpleGitStateAdapter();
const wuStateReader = new FileSystemWuStateAdapter();

// Use adapters
const location = await locationResolver.resolveLocation();
const gitState = await gitStateReader.readGitState();
const wuState = await wuStateReader.readWuState('WU-1094', '/repo');
```

### Validation Adapters

```typescript
import { CommandRegistryAdapter } from '@lumenflow/core';

const registry = new CommandRegistryAdapter();
const definition = registry.getCommandDefinition('wu:done');
const validCommands = registry.getValidCommandsForContext(context);
```

### Recovery Adapters

```typescript
import { RecoveryAnalyzerAdapter } from '@lumenflow/core';

const analyzer = new RecoveryAnalyzerAdapter();
const analysis = await analyzer.analyzeRecovery(context);
```

## Use Cases with Dependency Injection

WU-1094 introduces use case classes with constructor injection for all dependencies:

### ComputeContextUseCase

Orchestrates context computation using injected adapters.

```typescript
import {
  ComputeContextUseCase,
  SimpleGitLocationAdapter,
  SimpleGitStateAdapter,
  FileSystemWuStateAdapter,
  LocationType,
} from '@lumenflow/core';

// Manual wiring
const useCase = new ComputeContextUseCase(
  new SimpleGitLocationAdapter(),
  new SimpleGitStateAdapter(),
  new FileSystemWuStateAdapter(),
);

const context = await useCase.execute({ wuId: 'WU-1094' });
// Use LocationType constant for comparison
if (context.location.type === LocationType.MAIN) {
  console.log('Running from main checkout');
} else if (context.location.type === LocationType.WORKTREE) {
  console.log('Running from worktree');
}
```

### ValidateCommandUseCase

Validates commands against WU context.

```typescript
import { ValidateCommandUseCase, CommandRegistryAdapter } from '@lumenflow/core';

const useCase = new ValidateCommandUseCase(new CommandRegistryAdapter());

const result = await useCase.execute('wu:done', context);
if (!result.valid) {
  console.error(result.errors[0].message);
  console.log('Fix:', result.errors[0].fixCommand);
}
```

### AnalyzeRecoveryUseCase

Analyzes WU state for recovery issues.

```typescript
import { AnalyzeRecoveryUseCase, RecoveryAnalyzerAdapter } from '@lumenflow/core';

const useCase = new AnalyzeRecoveryUseCase(new RecoveryAnalyzerAdapter());

const analysis = await useCase.execute(context);
if (analysis.hasIssues) {
  for (const action of analysis.actions) {
    console.log(`Action: ${action.description}`);
    console.log(`Command: ${action.command}`);
  }
}
```

## Factory Functions (DI Container)

For convenience, factory functions create fully wired use cases with default or custom adapters:

```typescript
import {
  createComputeContextUseCase,
  createValidateCommandUseCase,
  createAnalyzeRecoveryUseCase,
  createContextAdapters,
  createValidationAdapters,
  createRecoveryAdapters,
} from '@lumenflow/core';

// Use defaults
const computeContext = createComputeContextUseCase();
const validateCommand = createValidateCommandUseCase();
const analyzeRecovery = createAnalyzeRecoveryUseCase();

// Or inject custom adapters (useful for testing)
import { LocationType } from '@lumenflow/core';

const mockLocationResolver = {
  resolveLocation: async () => ({
    type: LocationType.MAIN,
    cwd: '/test',
    gitRoot: '/test',
    mainCheckout: '/test',
    worktreeName: null,
    worktreeWuId: null,
  }),
};

const testUseCase = createComputeContextUseCase({
  locationResolver: mockLocationResolver,
  // gitStateReader and wuStateReader use defaults
});
```

## Backwards Compatible Functions

For simple use cases, convenience functions are available:

```typescript
import { computeWuContext, validateCommand, analyzeRecoveryIssues } from '@lumenflow/core';

// Compute context (uses default adapters internally)
const context = await computeWuContext({ wuId: 'WU-1094' });

// Validate a command
const validation = await validateCommand('wu:done', context);

// Analyze for recovery issues
const recovery = await analyzeRecoveryIssues(context);
```

These wrap the use case factories for drop-in use.
