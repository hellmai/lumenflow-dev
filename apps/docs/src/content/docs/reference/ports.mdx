---
title: Port Interfaces
description: Hexagonal architecture ports for context-aware validation
---

LumenFlow uses hexagonal architecture with port interfaces to enable dependency injection and testing. External users can inject custom implementations.

## Context Ports

### ILocationResolver

Resolves the current working directory context to determine main checkout vs worktree.

```typescript
import type { ILocationResolver } from '@lumenflow/core';
import { resolveLocation } from '@lumenflow/core';

// Default implementation
const resolver: ILocationResolver = { resolveLocation };

// Custom implementation for testing
const mockResolver: ILocationResolver = {
  resolveLocation: async (cwd) => ({
    type: 'main',
    cwd: cwd || '/repo',
    gitRoot: '/repo',
    mainCheckout: '/repo',
    worktreeName: null,
    worktreeWuId: null,
  }),
};
```

**Method**: `resolveLocation(cwd?: string): Promise<LocationContext>`

Returns:

- `type`: `'main'` | `'worktree'` | `'detached'` | `'unknown'`
- `cwd`: Absolute path to current working directory
- `gitRoot`: Git root (top-level of working tree)
- `mainCheckout`: Path to main checkout (primary repo)
- `worktreeName`: Worktree name if in worktree (e.g., `'framework-core-wu-1090'`)
- `worktreeWuId`: WU ID extracted from worktree (e.g., `'WU-1090'`)

### IGitStateReader

Reads current git state including branch, dirty status, and ahead/behind counts.

```typescript
import type { IGitStateReader } from '@lumenflow/core';
import { readGitState } from '@lumenflow/core';

// Default implementation
const reader: IGitStateReader = { readGitState };

// Custom implementation for testing
const mockReader: IGitStateReader = {
  readGitState: async () => ({
    branch: 'main',
    isDetached: false,
    isDirty: false,
    hasStaged: false,
    ahead: 0,
    behind: 0,
    tracking: 'origin/main',
    modifiedFiles: [],
    hasError: false,
    errorMessage: null,
  }),
};
```

**Method**: `readGitState(cwd?: string): Promise<GitState>`

Returns:

- `branch`: Current branch name (null if detached)
- `isDetached`: Whether HEAD is detached
- `isDirty`: Working tree has uncommitted changes
- `hasStaged`: Has staged changes
- `ahead`: Commits ahead of tracking branch
- `behind`: Commits behind tracking branch
- `tracking`: Tracking branch (e.g., `'origin/main'`)
- `modifiedFiles`: List of modified files
- `hasError`: Whether an error occurred
- `errorMessage`: Error message if applicable

### IWuStateReader

Reads WU state from YAML file and cross-references with state store.

```typescript
import type { IWuStateReader } from '@lumenflow/core';
import { readWuState } from '@lumenflow/core';

// Default implementation
const reader: IWuStateReader = { readWuState };

// Custom implementation for testing
const mockReader: IWuStateReader = {
  readWuState: async (wuId, repoRoot) => ({
    id: wuId,
    status: 'in_progress',
    lane: 'Framework: Core',
    title: 'Test WU',
    yamlPath: `${repoRoot}/docs/04-operations/tasks/wu/${wuId}.yaml`,
    isConsistent: true,
    inconsistencyReason: null,
  }),
};
```

**Method**: `readWuState(wuId: string, repoRoot: string): Promise<WuStateResult | null>`

Returns:

- `id`: WU ID (uppercase)
- `status`: Current status from YAML
- `lane`: Lane name
- `title`: WU title
- `yamlPath`: Absolute path to WU YAML file
- `isConsistent`: Whether YAML and state store agree
- `inconsistencyReason`: Reason if inconsistent

## Validation Ports

### ICommandRegistry

Provides command definitions and validation logic for wu:\* commands.

```typescript
import type { ICommandRegistry } from '@lumenflow/core';
import {
  getCommandDefinition,
  getValidCommandsForContext,
  COMMAND_REGISTRY,
} from '@lumenflow/core';

// Default implementation
const registry: ICommandRegistry = {
  getCommandDefinition,
  getValidCommandsForContext,
  getAllCommands: () => Array.from(COMMAND_REGISTRY.values()),
};
```

**Methods**:

- `getCommandDefinition(command: string): CommandDefinition | null`
- `getValidCommandsForContext(context: WuContext): CommandDefinition[]`
- `getAllCommands(): CommandDefinition[]`

## Recovery Ports

### IRecoveryAnalyzer

Analyzes WU context to detect state inconsistencies and suggest recovery actions.

```typescript
import type { IRecoveryAnalyzer } from '@lumenflow/core';
import { analyzeRecovery } from '@lumenflow/core';

// Default implementation
const analyzer: IRecoveryAnalyzer = { analyzeRecovery };

// Custom implementation for testing
const mockAnalyzer: IRecoveryAnalyzer = {
  analyzeRecovery: async (context) => ({
    hasIssues: false,
    issues: [],
    actions: [],
    wuId: context.wu?.id ?? null,
  }),
};
```

**Method**: `analyzeRecovery(context: WuContext): Promise<RecoveryAnalysis>`

Returns:

- `hasIssues`: Whether any issues were found
- `issues`: Array of `RecoveryIssue` objects
- `actions`: Array of suggested `RecoveryAction` objects
- `wuId`: WU ID analyzed

Issue codes:

- `PARTIAL_CLAIM`: Worktree exists but status is ready
- `ORPHAN_CLAIM`: Status is in_progress but worktree missing
- `INCONSISTENT_STATE`: YAML and state store disagree
- `ORPHAN_BRANCH`: Branch exists but worktree missing
- `STALE_LOCK`: Lock file from old session
- `LEFTOVER_WORKTREE`: WU is done but worktree exists

Action types:

- `resume`: Reconcile state and continue (preserves work)
- `reset`: Discard worktree, reset to ready
- `nuke`: Remove all artifacts (requires --force)
- `cleanup`: Remove leftover worktree

## Domain Schemas

All domain types have corresponding Zod schemas for runtime validation.

```typescript
import {
  LocationContextSchema,
  GitStateSchema,
  WuStateResultSchema,
  ValidationErrorSchema,
  RecoveryAnalysisSchema,
} from '@lumenflow/core';

// Validate runtime data
const result = LocationContextSchema.safeParse(unknownData);
if (result.success) {
  const location = result.data; // Type: LocationContext
}
```

See `@lumenflow/core` package exports for all available schemas and types.
