---
title: Lanes
description: Parallel work streams with WIP limits
---

Lanes are parallel work streams that organize work by domain and prevent overload through WIP (Work-in-Progress) limits.

## Why Lanes?

Without lanes:

- Everything competes for attention
- Context switching kills productivity
- Bottlenecks form unpredictably

With lanes:

- Work is organized by domain
- Each lane has focused attention
- WIP limits prevent overload

## Lane Lifecycle

Lane design is an explicit lifecycle process:

`unconfigured -> draft -> locked`

`lumenflow init` bootstraps tooling and sets lane lifecycle to `unconfigured`. Before creating delivery WUs, run:

```bash
pnpm lane:setup
pnpm lane:validate
pnpm lane:lock
```

Check current state any time:

```bash
pnpm lane:status
```

## Defining Lanes

Lanes use a `Parent: Sublane` naming convention to organize work hierarchically:

```yaml
# .lumenflow.config.yaml
version: '2.0'

lanes:
  enforcement:
    require_parent: true # Enforce Parent: Sublane format
    allow_custom: false # Only taxonomy lanes allowed

  definitions:
    - name: 'Framework: Core'
      wip_limit: 1
      code_paths:
        - 'packages/@lumenflow/core/**'

    - name: 'Framework: CLI'
      wip_limit: 1
      code_paths:
        - 'packages/@lumenflow/cli/**'

    - name: 'Operations: Infrastructure'
      wip_limit: 1
      code_paths:
        - 'apps/**'
        - 'actions/**'

    - name: 'Content: Documentation'
      wip_limit: 1
      code_paths:
        - 'docs/**'
```

### Parent Lane Categories

| Parent     | Purpose                             |
| ---------- | ----------------------------------- |
| Framework  | Core libraries, CLI, memory, agents |
| Operations | Infrastructure, CI/CD, tooling      |
| Content    | Documentation, guides               |
| Experience | UI components, pages                |

## WIP Limits

WIP (Work-in-Progress) limits enforce **one active WU per lane** (WIP=1). This prevents:

- Context switching between multiple incomplete tasks
- Merge conflicts from parallel work in the same domain
- "Started but not finished" pile-ups

**Current behavior:** WIP=1 is enforced for all lanes. Attempting to claim a WU in an occupied lane will be blocked.

**Parallel work:** Use multiple lanes to work in parallel. Each lane can have one active WU, enabling concurrent work across different domains.

## Lock Policy

The `lock_policy` field controls how blocked WUs affect lane availability:

```yaml
lanes:
  definitions:
    - name: 'Content: Documentation'
      wip_limit: 1
      lock_policy: active # blocked WUs release lane lock
      code_paths:
        - 'docs/**'
```

| Policy   | Behavior                                                                 |
| -------- | ------------------------------------------------------------------------ |
| `all`    | Default. Blocked WUs count toward WIP. Lane stays occupied when blocked. |
| `active` | Only in_progress WUs count. Blocked WUs release the lane lock.           |
| `none`   | WIP checking disabled. Multiple WUs can be claimed regardless of status. |

### When to Use Each Policy

- **`all` (default)**: High-conflict lanes where blocked work may resume soon
- **`active`**: Low-conflict lanes like documentation where blocked work is unlikely to cause merge conflicts
- **`none`**: Experimental. Use only for lanes with guaranteed non-overlapping work

### Pilot Recommendation

Start with `lock_policy: active` on low-conflict lanes like **Content: Documentation**:

1. Documentation WUs are low-conflict (different files, few dependencies)
2. Blocked docs WUs rarely resume immediately
3. Easy rollback: change `active` back to `all` in config

### Rollback

If `lock_policy: active` causes issues:

1. Update `.lumenflow.config.yaml`: change `lock_policy: active` to `lock_policy: all`
2. Run `pnpm wu:unlock-lane --lane "<lane>"` to clear stale locks

## Lane Lock Lifecycle

Lane locks are file-based locks (`.lumenflow/locks/<lane-kebab>.lock`) that enforce WIP=1. The lock lifecycle has three key phases:

### Acquisition

When `wu:claim` runs, it creates a lock file atomically using the `wx` (write-exclusive) flag. The lock file contains metadata including the WU ID, timestamp, agent session, and the PID of the claiming process.

### Persistence

Because `wu:claim` is a short-lived CLI process, the PID stored in the lock becomes invalid as soon as the claim completes. This is expected behavior -- the lock persists on disk regardless of whether the original process is still running. The lock remains valid until explicitly released by `wu:done` or forcibly cleared.

### Release

Locks are released in three ways:

1. **Normal release**: `wu:done` removes the lock after merging
2. **Stale zombie auto-clear**: If a lock is both stale (older than 2 hours) AND the PID is no longer running, subsequent `wu:claim` calls auto-clear it. This handles genuinely abandoned locks from crashed processes.
3. **Manual unlock**: `pnpm wu:unlock-lane --lane "<lane>" --reason "<reason>"` with audit logging

### Zombie Detection Semantics

A "zombie lock" is one where the PID that created it is no longer running. However, a dead PID alone does NOT trigger auto-clearing. Since `wu:claim` exits immediately after creating the worktree, every lock will have a dead PID shortly after creation.

Auto-clearing requires BOTH conditions:

- The lock PID is no longer running (zombie)
- The lock is older than 2 hours (stale)

This prevents a second `wu:claim` from stealing a lane that was legitimately claimed by a recently exited `wu:claim` process.

### Why WIP=1 Matters

```
High WIP (anti-pattern):
‚Üí Multiple things started, none finished
‚Üí Context switching overhead
‚Üí Long cycle times
‚Üí Merge conflicts

WIP=1 (LumenFlow default):
‚Üí Finish one thing
‚Üí Start the next
‚Üí Steady flow
‚Üí Clean merges
```

## Lane Selection

When claiming a WU, specify the full `Parent: Sublane` format:

```bash
pnpm wu:claim --id WU-042 --lane "Experience: UI"
```

The WU spec should already have a lane assignment:

```yaml
# WU-042.yaml
id: WU-042
title: Add email validation
lane: 'Experience: UI' # ‚Üê Full Parent: Sublane format
```

## Auto-Detection via Paths

LumenFlow can auto-detect lanes based on file paths using the lane inference system:

```yaml
# .lumenflow.lane-inference.yaml
Framework:
  Core:
    code_paths:
      - 'packages/@lumenflow/core/**'
    keywords:
      - 'core library'
      - 'wu lifecycle'
```

If a WU's `code_paths` match a pattern, the sublane is suggested automatically.

Note: `.lumenflow.lane-inference.yaml` is created during lane lifecycle setup (not during `lumenflow init`).

## Multiple Lanes

A WU should belong to **one lane**. If work spans multiple domains:

1. **Split the WU** ‚Äì One WU per lane
2. **Choose primary** ‚Äì Assign to the most affected lane

### Example: Feature Spanning UI + Core

Instead of one WU:
‚ùå "Add user preferences (UI + API + DB)"

Split into:
‚úÖ WU-100: "Add preferences API" (lane: Framework: Core)
‚úÖ WU-101: "Add preferences UI" (lane: Experience: UI)
‚úÖ WU-102: "Add preferences schema" (lane: Operations: Infrastructure)

## Visualizing Lanes

The status file shows lane state:

```markdown
# Status

## üîß In Progress

- [WU-101 ‚Äî Add preferences UI](wu/WU-101.yaml) (lane: Experience: UI)
- [WU-100 ‚Äî Add preferences API](wu/WU-100.yaml) (lane: Framework: Core)

## üöÄ Ready

- [WU-103 ‚Äî Add dark mode toggle](wu/WU-103.yaml) (lane: Experience: UI) ‚Üê blocked (lane occupied)
- [WU-104 ‚Äî Add export feature](wu/WU-104.yaml) (lane: Operations: Infrastructure) ‚Üê can claim

## ‚õî Blocked

(none)
```

Note: WU-103 cannot be claimed because Experience: UI lane already has WU-101 in progress.

## Next Steps

- [Gates](/concepts/gates) ‚Äì Quality checks per lane
- [Team Workflow](/guides/team-workflow) ‚Äì Lane strategies for teams
