id: WU-2159
title: Implement HttpControlPlaneSyncPort adapter for cloud telemetry forwarding
lane: 'Operations: Runtime'
type: feature
status: ready
priority: P1
created: 2026-02-25
code_paths:
  - packages/@lumenflow/control-plane-sdk/src/http/http-control-plane-sync-port.ts
  - packages/@lumenflow/control-plane-sdk/src/index.ts
  - apps/web/src/server/http-surface-runtime.ts
tests:
  manual:
    - Verify cloud:connect writes config, then pnpm gates produces events that appear on cloud dashboard
    - 'Verify graceful degradation: disconnect network, run gates, confirm local operations succeed and warnings are logged'
  unit:
    - packages/@lumenflow/control-plane-sdk/__tests__/http-sync-port.test.ts
  e2e: []
artifacts:
  - .lumenflow/stamps/WU-2159.done
dependencies: []
spec_refs:
  - docs/04-operations/_frameworks/lumenflow/agent/onboarding/starting-prompt.md
risks: []
notes: |-
  ## Implementation notes

  ### Reference files
  - Port interface: packages/@lumenflow/control-plane-sdk/src/sync-port.ts (7 methods, all async)
  - Mock reference: packages/@lumenflow/control-plane-sdk/src/mock/mock-control-plane-sync-port.ts
  - Sync loop consumer: packages/@lumenflow/surfaces/http/control-plane-event-subscriber.ts (runSyncCycle: pullPolicies → heartbeat → pushKernelEvents)
  - Runtime wiring point: apps/web/src/server/http-surface-runtime.ts (readWorkspaceControlPlaneConfig + getControlPlaneDiagnostics)
  - Existing tests: packages/@lumenflow/surfaces/__tests__/control-plane-forwarding.test.ts (patterns for vi.useFakeTimers, mock port)
  - Config schema: packages/@lumenflow/control-plane-sdk/src/workspace-config.ts (ControlPlaneConfigSchema)

  ### Test workspace (for integration smoke test)
  - Endpoint: https://cloud.lumenflow.dev
  - Org ID: 10762bb6-1bf2-4c15-aa13-c4fd20bbc7b9
  - API key env: LUMENFLOW_CLOUD_TOKEN
  - Tier: Team (trialing)

  ### Architecture
  - HttpControlPlaneSyncPort goes in packages/@lumenflow/control-plane-sdk/src/http/ (mirrors mock/ directory pattern)
  - Export from index.ts alongside MockControlPlaneSyncPort
  - Factory function: createHttpControlPlaneSyncPort(config: WorkspaceControlPlaneConfig, logger?: Pick<Console, 'warn'>)
  - Use native fetch() — no axios/got/undici dependency
  - ControlPlaneSyncPortLike (minimal interface used by HTTP Surface) is a subset of full ControlPlaneSyncPort — the HTTP adapter implements the full interface

  ### Graceful degradation pattern
  - Wrap every fetch() in try/catch
  - On network error: logger.warn(), return default (empty policies / {accepted: 0} / {status: 'ok', server_time: now})
  - On non-2xx: logger.warn() with status code and response body, return default
  - On timeout: AbortController with configurable timeout, same warn + default pattern
  - NEVER throw from any public method
requires_review: false
assigned_to: tom@hellm.ai
exposure: backend-only
escalation_triggers: []
requires_human_escalation: false
requires_cso_approval: false
requires_cto_approval: false
requires_design_approval: false
description: |-
  ## Context

  The kernel writes gate events, WU flow events, and LLM classification telemetry to local NDJSON files (.lumenflow/telemetry/gates.ndjson, flow.log, llm-classification.ndjson) via emitGateEvent()/emitWUFlowEvent() in @lumenflow/core/telemetry. The workspace.yaml control_plane: block is written by lumenflow cloud:connect, and the ControlPlaneSyncPort interface exists with a mock implementation — but no HTTP adapter exists to actually call the Cloud REST API.

  ## Problem

  Dogfooding the lumenflow-cloud onboarding guide: steps 1-3 work (sign up, create workspace, connect kernel). Step 4 fails — pnpm gates writes events locally but the cloud dashboard shows nothing because no HTTP sync implementation exists. The port interface, mock, sync loop (in control-plane-event-subscriber.ts), and config schema are all in place — only the production adapter is missing.

  ## Solution

  Implement HttpControlPlaneSyncPort in @lumenflow/control-plane-sdk that maps the 7 port methods to Cloud REST API endpoints using native fetch(). Wire it into the web app runtime so that when control_plane: config is present in workspace.yaml, the real adapter is instantiated and injected into the HTTP Surface.

  ### Cloud REST API mapping

  | Port Method | Cloud Endpoint | Auth |
  |---|---|---|
  | authenticate() | POST /api/v1/authenticate | Bearer <api-key> |
  | heartbeat() | POST /api/v1/heartbeat | Bearer <api-key> |
  | pushKernelEvents() | POST /api/v1/events | Bearer <api-key> |
  | pushEvidence() | POST /api/v1/evidence | Bearer <api-key> |
  | pushTelemetry() | POST /api/v1/telemetry | Bearer <api-key> |
  | pullPolicies() | POST /api/v1/policies (or GET) | Bearer <api-key> |
  | pullConfig() | POST /api/v1/config (or GET) | Bearer <api-key> |

  Auth: reads API key from process.env[control_plane.auth.token_env], sends as Authorization: Bearer header.

  ### Key constraints

  - Graceful degradation: if Cloud is unreachable or returns errors, log warnings but NEVER block local operations or throw
  - Use native fetch() (Node 18+), no external HTTP library
  - Follow MockControlPlaneSyncPort as reference implementation pattern
  - Respect existing sync loop in control-plane-event-subscriber.ts (pullPolicies → heartbeat → pushKernelEvents cycle)
acceptance:
  - HttpControlPlaneSyncPort class implements ControlPlaneSyncPort interface with all 7 methods mapping to Cloud REST API endpoints via native fetch()
  - Constructor accepts WorkspaceControlPlaneConfig and reads API key from process.env[config.auth.token_env]
  - 'All HTTP calls include Authorization: Bearer <api-key> header and Content-Type: application/json'
  - 'Graceful degradation: network errors and non-2xx responses are caught, logged via injected logger, and never throw — returns sensible defaults (empty policy set, zero accepted count)'
  - Request timeout configurable (default 10s) to prevent hanging on unresponsive cloud endpoints
  - 'Runtime wiring in http-surface-runtime.ts: when control_plane config is present and valid, instantiate HttpControlPlaneSyncPort and inject into HttpSurface options'
  - 'Unit tests cover all 7 methods with msw or nock HTTP mocking: success path, error path (network failure), error path (non-2xx response), and timeout'
  - 'Integration smoke test: authenticate() against test workspace endpoint returns valid ControlPlaneIdentity (can be skipped in CI via env flag)'
