id: WU-1238
title: Add access tracking and decay scoring to memory layer
lane: 'Framework: Memory'
type: feature
status: ready
priority: P2
created: 2026-01-30
code_paths:
  - packages/@lumenflow/memory/src/memory-store.ts
  - packages/@lumenflow/memory/src/decay/scoring.ts
  - packages/@lumenflow/memory/src/decay/archival.ts
  - packages/@lumenflow/memory/src/mem-cleanup-core.ts
tests:
  manual: []
  unit:
    - packages/@lumenflow/memory/src/__tests__/decay-scoring.test.ts
    - packages/@lumenflow/memory/src/__tests__/access-tracking.test.ts
  e2e: []
artifacts:
  - .lumenflow/stamps/WU-1238.done
dependencies: []
risks: []
notes: ''
requires_review: false
assigned_to: tom@hellm.ai
exposure: backend-only
escalation_triggers: []
requires_human_escalation: false
requires_cso_approval: false
requires_cto_approval: false
requires_design_approval: false
description: 'Context: Without decay, context injection becomes noisy after 50+ WUs. Old, superseded decisions pollute new sessions. Project profiles grow unbounded. Problem: Memory relevance drifts over time. Frequently accessed, recent memories should rank higher than stale, rarely-used ones. Currently all memories are treated equally. Solution: Add access tracking and decay scoring using metadata fields (non-breaking, metadata-first approach). New metadata fields: metadata.access.count (increment on retrieval), metadata.access.last_accessed_at (ISO string), metadata.decay.score (computed), metadata.decay.reason (debuggable). Decay scoring algorithm: recencyScore = exp(-age / HALF_LIFE_MS), accessScore = log1p(access_count) / 10, importanceScore = priority P0=2, P1=1.5, P2=1, P3=0.5, decayScore = recencyScore * (1 + accessScore) * importanceScore. Access recorded when: node selected into mem:context, node returned in mem:search, optionally when mem:export includes it. Archival: nodes below threshold get metadata.status = archived (append-only pattern). Archived nodes excluded from default queries but searchable with --include-archived. Nothing deleted; relevance managed through selection filters.'
acceptance:
  - Access count increments when node returned by mem:search or mem:context
  - last_accessed_at updated on each access
  - Decay score computed using recency * access * importance formula
  - mem:cleanup --decay archives nodes below threshold (configurable, default 0.1)
  - Archived nodes get metadata.status = archived (not deleted)
  - Default queries exclude archived nodes; --include-archived flag includes them
  - Half-life configurable in .lumenflow.config.yaml (default 30 days)
  - Unit tests cover scoring algorithm, access tracking, and archival
  - Integration test verifies decay affects mem:context ranking
  - Documentation updated in memory package README
