id: WU-1238
title: Add access tracking and decay scoring to memory layer
lane: 'Framework: Memory'
type: feature
status: done
priority: P2
created: 2026-01-30
code_paths:
  - packages/@lumenflow/memory/src/memory-store.ts
  - packages/@lumenflow/memory/src/decay/scoring.ts
  - packages/@lumenflow/memory/src/decay/access-tracking.ts
  - packages/@lumenflow/memory/src/decay/archival.ts
  - packages/@lumenflow/memory/src/mem-cleanup-core.ts
  - packages/@lumenflow/memory/src/mem-context-core.ts
  - packages/@lumenflow/memory/src/index.ts
  - packages/@lumenflow/memory/README.md
tests:
  manual:
    - Verify acceptance criteria met
  unit:
    - packages/@lumenflow/memory/__tests__/decay-scoring.test.ts
    - packages/@lumenflow/memory/__tests__/access-tracking.test.ts
    - packages/@lumenflow/memory/__tests__/archival.test.ts
    - packages/@lumenflow/memory/__tests__/decay-integration.test.ts
  e2e: []
artifacts:
  - .lumenflow/stamps/WU-1238.done
dependencies:
  - WU-1234
  - WU-1237
initiative: INIT-008
phase: 3
spec_refs:
  - internal
risks: []
notes: Completed per acceptance criteria.
requires_review: false
assigned_to: tom@hellm.ai
exposure: backend-only
escalation_triggers: []
requires_human_escalation: false
requires_cso_approval: false
requires_cto_approval: false
requires_design_approval: false
description: 'Context: Without decay, context injection becomes noisy after 50+ WUs. Old, superseded
  decisions pollute new sessions. Project profiles grow unbounded. Problem: Memory relevance drifts
  over time. Frequently accessed, recent memories should rank higher than stale, rarely-used ones.
  Currently all memories are treated equally. Solution: Add access tracking and decay scoring using
  metadata fields (non-breaking, metadata-first approach). New metadata fields:
  metadata.access.count (increment on retrieval), metadata.access.last_accessed_at (ISO string),
  metadata.decay.score (computed), metadata.decay.reason (debuggable). Decay scoring algorithm:
  recencyScore = exp(-age / HALF_LIFE_MS), accessScore = log1p(access_count) / 10, importanceScore =
  priority P0=2, P1=1.5, P2=1, P3=0.5, decayScore = recencyScore * (1 + accessScore) *
  importanceScore. Access recorded when: node selected into mem:context, node returned in
  mem:search, optionally when mem:export includes it. Archival: nodes below threshold get
  metadata.status = archived (append-only pattern). Archived nodes excluded from default queries but
  searchable with --include-archived. Nothing deleted; relevance managed through selection filters.'
acceptance:
  - Access count increments when node returned by mem:search or mem:context
  - last_accessed_at updated on each access
  - Decay score computed using recency * access * importance formula
  - mem:cleanup --decay archives nodes below threshold (configurable, default 0.1)
  - Archived nodes get metadata.status = archived (not deleted)
  - Default queries exclude archived nodes; --include-archived flag includes them
  - Half-life configurable in .lumenflow.config.yaml (default 30 days)
  - Unit tests cover scoring algorithm, access tracking, and archival
  - Integration test verifies decay affects mem:context ranking
  - Documentation updated in memory package README
claimed_mode: worktree
worktree_path: /home/tom/source/hellmai/os/worktrees/framework-memory-wu-1238
claimed_at: 2026-01-31T15:36:34.139Z
baseline_main_sha: 14df84bb26828a539a20fb918c8c56874a0efc8a
session_id: ed45845a-ecbf-496c-9619-540fb8dd80a6
approved_by:
  - tom@hellm.ai
approved_at: 2026-01-31T15:36:34.146Z
locked: true
completed_at: 2026-01-31T16:00:01.567Z
