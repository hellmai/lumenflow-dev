id: WU-1729
title: Kernel ToolHost execution + EvidenceStore with CAS and receipts
lane: 'Framework: Core Lifecycle'
type: feature
status: ready
priority: P0
created: 2026-02-16
code_paths:
  - packages/@lumenflow/kernel/src/tool-host/
  - packages/@lumenflow/kernel/src/evidence/
tests:
  manual:
    - pnpm typecheck passes for kernel package
  unit:
    - packages/@lumenflow/kernel/src/__tests__/tool-host.test.ts
    - packages/@lumenflow/kernel/src/__tests__/evidence-store.test.ts
  e2e: []
artifacts:
  - .lumenflow/stamps/WU-1729.done
dependencies: []
initiative: INIT-029
phase: 2
blocked_by:
  - WU-1728
  - WU-1726
labels:
  - kernel
  - phase-2
  - tool-host
  - evidence
spec_refs:
  - .claude/plans/golden-prancing-cookie.md
risks: []
notes: (auto) Add implementation notes, rollout context, or a short summary of the plan/conversation.
requires_review: false
assigned_to: tom@hellm.ai
exposure: backend-only
escalation_triggers: []
requires_human_escalation: false
requires_cso_approval: false
requires_cto_approval: false
requires_design_approval: false
description: 'Context: INIT-029 Phase 2 — ToolHost + Evidence. Depends on WU-1728 (ToolRegistry) and
  WU-1726 (EventStore). Problem: Tool execution needs a security boundary that validates scopes,
  enforces policy, and produces immutable receipts with provenance for replay determinism. This is
  the killer differentiator — agents cannot go off-script. Solution: ToolHost class wrapping
  ToolRegistry — validates input, resolves scopes (workspace ∩ lane ∩ task ∩ tool, all ToolScope[]),
  calls policy hook (stub for now), dispatches to handler (in-process or subprocess), emits receipt.
  EvidenceStore for receipts (append JSONL). CAS store for tool inputs (SHA-256 ->
  evidence/inputs/{hash}). ToolReceipt with schema_version:1, honest scope semantics
  (scope_requested/allowed/enforced + scope_enforcement_note), and provenance fields (tool_version,
  pack_id/version/integrity, workspace_config_hash, runtime_version). Reference: tool-runner.ts.
  Plan: .claude/plans/golden-prancing-cookie.md'
acceptance:
  - ToolHost class wraps ToolRegistry with execute(name, input, ctx) method
  - ToolHost validates input against tool schema before execution
  - 'ToolHost resolves scope intersection: workspace ∩ lane ∩ task ∩ tool (all ToolScope[])'
  - 'ToolHost dispatches to handler.kind: in-process calls fn directly, subprocess delegates to
    worker'
  - ToolHost calls policy hook stub (allow-all for now, replaced in Phase 3)
  - ToolReceipt includes schema_version:1 for stable control plane ingestion
  - 'ToolReceipt includes honest scope semantics: scope_requested, scope_allowed, scope_enforced,
    scope_enforcement_note'
  - 'ToolReceipt includes provenance: tool_version, pack_id, pack_version, pack_integrity,
    workspace_config_hash, runtime_version'
  - EvidenceStore appends receipts as JSONL to evidence/traces/
  - 'CAS store: tool inputs hashed with SHA-256 and stored in evidence/inputs/{hash}'
  - Execute within allowed scope produces success receipt with input_ref pointing to CAS
  - Execute outside allowed scope produces denied receipt — hard boundary not hook
