id: WU-1726
title: 'Kernel EventStore: JSONL append, indexes, projections'
lane: 'Framework: Core Lifecycle'
type: feature
status: ready
priority: P0
created: 2026-02-16
code_paths:
  - packages/@lumenflow/kernel/src/event-store/
tests:
  manual:
    - pnpm typecheck passes for kernel package
  unit:
    - packages/@lumenflow/kernel/src/__tests__/event-store.test.ts
  e2e: []
artifacts:
  - .lumenflow/stamps/WU-1726.done
dependencies: []
initiative: INIT-029
phase: 1
blocked_by:
  - WU-1725
labels:
  - kernel
  - phase-1
  - event-sourcing
spec_refs:
  - .claude/plans/golden-prancing-cookie.md
risks: []
notes: (auto) Add implementation notes, rollout context, or a short summary of the plan/conversation.
requires_review: false
assigned_to: tom@hellm.ai
exposure: backend-only
escalation_triggers: []
requires_human_escalation: false
requires_cso_approval: false
requires_cto_approval: false
requires_design_approval: false
description: 'Context: INIT-029 Phase 1 â€” Kernel Foundation. Depends on WU-1725 (schemas). Problem:
  The kernel needs an event-sourced state store for task lifecycle events with unambiguous
  projection semantics for blocked/waiting/resumed flows. Current wu-state-store.ts has the right
  pattern (JSONL append-only, in-memory indexes, replay) but is entangled with WU-specific concerns.
  Solution: Implement a generic EventStore class with append(event), replay(filter),
  project(taskId). Events use KernelEvent discriminated union with prefixed kinds (task_, run_,
  workspace_, spec_) and schema_version:1, including task_waiting/task_resumed lifecycle events.
  JSONL backend ports wu-state-store.ts patterns. In-memory indexes (byTask, byKind, byTimestamp).
  projectTaskState(spec, events) -> TaskState projection. File locking via atomic wx flag pattern
  from lane-lock.ts. Spec hash verification on load via canonical_json against
  task_created.spec_hash. Reference: wu-state-store.ts, lane-lock.ts. Plan:
  .claude/plans/golden-prancing-cookie.md'
acceptance:
  - EventStore class implements append(event), replay(filter), project(taskId)
  - JSONL file backend with atomic append (fs.appendFile)
  - 'In-memory indexes: byTask, byKind, byTimestamp with O(1) lookups'
  - projectTaskState(spec, events) correctly projects TaskState from event stream
  - File locking via atomic fs.open with wx flag prevents concurrent corruption
  - 'Append-replay roundtrip test: append N events, replay, verify all present and ordered'
  - 'Projection correctness test: create->claim->block->unblock->complete produces correct final
    state'
  - "Concurrent-append safety test: multiple appends don't corrupt JSONL"
  - EventStore stores KernelEvent union (task_, run_, workspace_, spec_ prefixed kinds) with
    schema_version:1
  - 'Spec hash verification: recompute canonical_json() hash on load and verify against task_created
    spec_hash'
  - KernelEvent lifecycle coverage includes task_waiting and task_resumed transitions for
    waiting-state projection
  - Projection correctness test includes waiting/resumed path
    (create->claim->waiting->resumed->complete)
