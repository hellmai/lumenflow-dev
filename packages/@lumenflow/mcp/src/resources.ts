/**
 * @file resources.ts
 * @description MCP resource implementations for LumenFlow
 *
 * WU-1412: Resources available: context, wu/{id}, backlog
 *
 * Resources provide read access to LumenFlow data via URI patterns.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { runCliCommand } from './cli-runner.js';

// Lazy load core module for context
let coreModule: typeof import('@lumenflow/core') | null = null;

async function getCore() {
  if (!coreModule) {
    coreModule = await import('@lumenflow/core');
  }
  return coreModule;
}

/**
 * Resource definition
 */
export interface ResourceDefinition {
  /** Static resource URI (for fixed resources) */
  uri?: string;
  /** URI template (for parameterized resources) */
  uriTemplate?: string;
  /** Resource name */
  name: string;
  /** Resource description */
  description: string;
  /** MIME type of the resource content */
  mimeType: string;
  /** Fetch the resource content */
  fetch: (uri: string, options?: { projectRoot?: string }) => Promise<ResourceResult>;
}

/**
 * Resource result
 */
export interface ResourceResult {
  success: boolean;
  content?: string;
  error?: string;
}

/**
 * context - Current LumenFlow context
 */
export const contextResource: ResourceDefinition = {
  uri: 'lumenflow://context',
  name: 'LumenFlow Context',
  description: 'Current LumenFlow context including location, git state, and active WU',
  mimeType: 'application/json',

  async fetch(_uri, options) {
    try {
      const core = await getCore();
      const context = await core.computeWuContext({
        cwd: options?.projectRoot,
      });
      return {
        success: true,
        content: JSON.stringify(context, null, 2),
      };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
      };
    }
  },
};

/**
 * wu/{id} - WU specification by ID
 */
export const wuResource: ResourceDefinition = {
  uriTemplate: 'lumenflow://wu/{id}',
  name: 'Work Unit',
  description: 'Work Unit specification by ID',
  mimeType: 'application/json',

  async fetch(uri, options) {
    try {
      // Extract ID from URI: lumenflow://wu/WU-1412 -> WU-1412
      const match = /^lumenflow:\/\/wu\/(.+)$/.exec(uri);
      if (!match) {
        return { success: false, error: 'Invalid WU URI format' };
      }
      const id = match[1] ?? '';

      // Use CLI to get WU status (includes full WU context)
      const result = await runCliCommand('wu:status', ['--id', id, '--json'], {
        projectRoot: options?.projectRoot,
      });

      if (result.success) {
        return {
          success: true,
          content: result.stdout,
        };
      } else {
        return {
          success: false,
          error: result.stderr || result.error?.message || 'Failed to get WU',
        };
      }
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
      };
    }
  },
};

/**
 * backlog - Current backlog state
 * Reads the backlog.md file directly (generated by LumenFlow CLI)
 */
export const backlogResource: ResourceDefinition = {
  uri: 'lumenflow://backlog',
  name: 'Backlog',
  description: 'Current LumenFlow backlog with all WUs grouped by status',
  mimeType: 'text/markdown',

  async fetch(_uri, options) {
    try {
      const projectRoot = options?.projectRoot || process.cwd();
      // Security: path is constructed from known static segments, not user input
      const backlogPath = path.join(projectRoot, 'docs', '04-operations', 'tasks', 'backlog.md');

      // eslint-disable-next-line security/detect-non-literal-fs-filename
      const content = await fs.readFile(backlogPath, 'utf-8');
      return {
        success: true,
        content,
      };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
      };
    }
  },
};

/**
 * All static resources (fixed URIs)
 */
export const staticResources: ResourceDefinition[] = [contextResource, backlogResource];

/**
 * All resource templates (parameterized URIs)
 */
export const resourceTemplates: ResourceDefinition[] = [wuResource];

/**
 * All resources
 */
export const allResources: ResourceDefinition[] = [...staticResources, ...resourceTemplates];
