import { appendFile, mkdir, open, readFile } from 'node:fs/promises';
import { createHash } from 'node:crypto';
import { join } from 'node:path';
import { canonical_json } from '../canonical-json.js';
import {
  ToolTraceEntrySchema,
  type PolicyDecision,
  type ToolTraceEntry,
} from '../kernel.schemas.js';

export interface EvidenceStoreOptions {
  evidenceRoot: string;
}

export interface PersistInputResult {
  inputHash: string;
  inputRef: string;
}

function sha256Hex(content: string): string {
  return createHash('sha256').update(content).digest('hex');
}

export class EvidenceStore {
  private readonly tracesDir: string;
  private readonly tracesFilePath: string;
  private readonly inputsDir: string;

  constructor(options: EvidenceStoreOptions) {
    this.tracesDir = join(options.evidenceRoot, 'traces');
    this.tracesFilePath = join(this.tracesDir, 'tool-traces.jsonl');
    this.inputsDir = join(options.evidenceRoot, 'inputs');
  }

  async appendTrace(entry: ToolTraceEntry): Promise<void> {
    const validated = ToolTraceEntrySchema.parse(entry);
    await mkdir(this.tracesDir, { recursive: true });
    await appendFile(this.tracesFilePath, `${JSON.stringify(validated)}\n`, 'utf8');
  }

  async readTraces(): Promise<ToolTraceEntry[]> {
    let content: string;
    try {
      content = await readFile(this.tracesFilePath, 'utf8');
    } catch (error) {
      const nodeError = error as NodeJS.ErrnoException;
      if (nodeError.code === 'ENOENT') {
        return [];
      }
      throw error;
    }

    const lines = content
      .split('\n')
      .map((line) => line.trim())
      .filter(Boolean);
    const traces: ToolTraceEntry[] = [];
    for (const line of lines) {
      traces.push(ToolTraceEntrySchema.parse(JSON.parse(line)));
    }
    return traces;
  }

  async persistInput(input: unknown): Promise<PersistInputResult> {
    const serialized = canonical_json(input);
    const inputHash = sha256Hex(serialized);
    const inputRef = join(this.inputsDir, inputHash);
    await mkdir(this.inputsDir, { recursive: true });

    try {
      const handle = await open(inputRef, 'wx');
      try {
        await handle.writeFile(serialized, 'utf8');
      } finally {
        await handle.close();
      }
    } catch (error) {
      const nodeError = error as NodeJS.ErrnoException;
      if (nodeError.code !== 'EEXIST') {
        throw error;
      }
    }

    return {
      inputHash,
      inputRef,
    };
  }

  async reconcileOrphanedStarts(): Promise<number> {
    const traces = await this.readTraces();
    const started = new Map<string, ToolTraceEntry>();
    const finished = new Set<string>();

    for (const trace of traces) {
      if (trace.kind === 'tool_call_started') {
        started.set(trace.receipt_id, trace);
      } else {
        finished.add(trace.receipt_id);
      }
    }

    let reconciled = 0;
    for (const [receiptId] of started) {
      if (finished.has(receiptId)) {
        continue;
      }
      const policyDecisions: PolicyDecision[] = [
        {
          policy_id: 'kernel.reconciliation',
          decision: 'deny',
          reason: 'Orphaned started trace without matching finished trace',
        },
      ];
      await this.appendTrace({
        schema_version: 1,
        kind: 'tool_call_finished',
        receipt_id: receiptId,
        timestamp: new Date().toISOString(),
        result: 'crashed',
        duration_ms: 0,
        scope_enforcement_note: 'Synthetic crashed finish generated by orphan reconciliation.',
        policy_decisions: policyDecisions,
        artifacts_written: [],
      });
      reconciled += 1;
    }

    return reconciled;
  }
}
