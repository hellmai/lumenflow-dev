#!/usr/bin/env node
/**
 * WU Cleanup Helper
 *
 * Cleans up worktree and branch after PR merge (PR-based completion workflow).
 *
 * Sequence:
 * 1) Verify PR is merged (via gh API or git merge-base fallback)
 * 2) Remove worktree (if exists)
 * 3) Delete lane branch (local + remote)
 *
 * Idempotent: Safe no-op if already cleaned.
 *
 * Usage:
 *   pnpm wu:cleanup --id WU-703
 *   pnpm wu:cleanup --artifacts
 */

import { execSync } from 'node:child_process';
import { getGitForCwd } from '@lumenflow/core/dist/git-adapter.js';
import { existsSync } from 'node:fs';
import path from 'node:path';
import { createWUParser, WU_OPTIONS } from '@lumenflow/core/dist/arg-parser.js';
import { die } from '@lumenflow/core/dist/error-handler.js';
import { cleanupWorktreeBuildArtifacts } from '@lumenflow/core/dist/rebase-artifact-cleanup.js';
import { detectCurrentWorktree } from '@lumenflow/core/dist/wu-done-validators.js';
import { WU_PATHS } from '@lumenflow/core/dist/wu-paths.js';
import { readWU } from '@lumenflow/core/dist/wu-yaml.js';
import {
  BRANCHES,
  EXIT_CODES,
  FILE_SYSTEM,
  LOG_PREFIX,
  REMOTES,
  GIT_REFS,
} from '@lumenflow/core/dist/wu-constants.js';
// WU-2278: Import ownership validation for cross-agent protection
import { validateWorktreeOwnership } from '@lumenflow/core/dist/worktree-ownership.js';
/* eslint-disable security/detect-non-literal-fs-filename */

// Box drawing characters for consistent output
const BOX = {
  TOP: '╔═══════════════════════════════════════════════════════════════════╗',
  MID: '╠═══════════════════════════════════════════════════════════════════╣',
  BOT: '╚═══════════════════════════════════════════════════════════════════╝',
};

const CLEANUP_OPTIONS = {
  artifacts: {
    name: 'artifacts',
    flags: '--artifacts',
    description: 'Remove build artifacts (dist, tsbuildinfo) in current worktree',
  },
};

// Help text is now auto-generated by commander via createWUParser

async function verifyPRMerged(laneBranch) {
  // Try gh API first (most reliable)
  let ghResult;
  try {
    ghResult = execSync(
      `gh api repos/:owner/:repo/pulls -q '.[] | select(.head.ref == "${laneBranch}") | .merged'`,
      { encoding: FILE_SYSTEM.UTF8 as BufferEncoding },
    ).trim();
  } catch {
    ghResult = '';
  }

  if (ghResult === 'true') {
    return { merged: true, method: 'gh_api' };
  }
  if (ghResult === 'false') {
    return { merged: false, method: 'gh_api' };
  }

  // Fallback: git merge-base --is-ancestor
  // Always fetch origin/main first for accurate merge-base check
  await getGitForCwd().fetch(REMOTES.ORIGIN, BRANCHES.MAIN);

  const localBranchExists = await getGitForCwd().branchExists(laneBranch);
  if (!localBranchExists) {
    // Branch doesn't exist locally - check if it exists remotely
    const remoteBranchExists = await getGitForCwd().raw([
      'ls-remote',
      '--heads',
      REMOTES.ORIGIN,
      laneBranch,
    ]);
    if (!remoteBranchExists) {
      // Branch is gone both locally and remotely - assume merged
      return { merged: true, method: 'branch_deleted' };
    }
    // Branch exists remotely but not locally - need to fetch
    await getGitForCwd().fetch(REMOTES.ORIGIN, laneBranch);
  }

  let isAncestor;
  try {
    await getGitForCwd().raw(['merge-base', '--is-ancestor', laneBranch, GIT_REFS.ORIGIN_MAIN]);
    isAncestor = true;
  } catch {
    isAncestor = false;
  }

  if (isAncestor) {
    return { merged: true, method: 'git_merge_base' };
  }

  return { merged: false, method: 'git_merge_base' };
}

async function removeWorktree(worktreePath) {
  if (!existsSync(worktreePath)) {
    console.log(`[wu-cleanup] ✓ Worktree already removed: ${worktreePath}`);
    return;
  }

  console.log(`[wu-cleanup] Removing worktree: ${worktreePath}`);
  await getGitForCwd().worktreeRemove(worktreePath, { force: true });
  console.log('[wu-cleanup] ✓ Worktree removed');
}

async function deleteBranch(laneBranch) {
  // Delete local branch
  const localExists = await getGitForCwd().branchExists(laneBranch);
  if (localExists) {
    console.log(`[wu-cleanup] Deleting local branch: ${laneBranch}`);
    await getGitForCwd().deleteBranch(laneBranch, { force: true });
    console.log('[wu-cleanup] ✓ Local branch deleted');
  } else {
    console.log(`[wu-cleanup] ✓ Local branch already deleted: ${laneBranch}`);
  }

  // Delete remote branch
  const remoteExists = await getGitForCwd().raw([
    'ls-remote',
    '--heads',
    REMOTES.ORIGIN,
    laneBranch,
  ]);
  if (remoteExists) {
    console.log(`[wu-cleanup] Deleting remote branch: ${laneBranch}`);
    await getGitForCwd().raw(['push', REMOTES.ORIGIN, '--delete', laneBranch]);
    console.log('[wu-cleanup] ✓ Remote branch deleted');
  } else {
    console.log(`[wu-cleanup] ✓ Remote branch already deleted: ${laneBranch}`);
  }
}

async function cleanupArtifactsInWorktree() {
  const worktreePath = detectCurrentWorktree();
  if (!worktreePath) {
    die(
      `${LOG_PREFIX.CLEANUP} Not in a worktree.\n\n` +
        'Run this command from inside a worktree:\n' +
        '  cd worktrees/<lane>-wu-xxx\n' +
        '  pnpm wu:cleanup --artifacts\n',
    );
  }

  console.log(`${LOG_PREFIX.CLEANUP} Cleaning build artifacts in ${worktreePath}`);

  const result = await cleanupWorktreeBuildArtifacts(worktreePath);

  if (result.removedCount === 0) {
    console.log(`${LOG_PREFIX.CLEANUP} ✓ No build artifacts found`);
    return;
  }

  if (result.distDirectories.length > 0) {
    console.log(`${LOG_PREFIX.CLEANUP} Removed dist directories:`);
    for (const dir of result.distDirectories) {
      console.log(`  - ${dir}`);
    }
  }

  if (result.tsbuildinfoFiles.length > 0) {
    console.log(`${LOG_PREFIX.CLEANUP} Removed tsbuildinfo files:`);
    for (const file of result.tsbuildinfoFiles) {
      console.log(`  - ${file}`);
    }
  }

  console.log(`${LOG_PREFIX.CLEANUP} ✓ Build artifact cleanup complete`);
}

async function main() {
  const args = createWUParser({
    name: 'wu-cleanup',
    description: 'Clean up worktree and branch after PR merge (PR-based completion workflow)',
    options: [WU_OPTIONS.id, CLEANUP_OPTIONS.artifacts],
    required: [],
    allowPositionalId: true,
  });

  if (args.artifacts) {
    await cleanupArtifactsInWorktree();
    return;
  }

  if (!args.id) {
    die(`${LOG_PREFIX.CLEANUP} Missing required --id (or use --artifacts).`);
  }

  const id = args.id.toUpperCase();
  const wu = readWU(WU_PATHS.WU(id), id);

  // Use kebab-case lane naming (match wu-claim.mjs logic)
  const laneK =
    wu.lane
      ?.toLowerCase()
      .trim()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '') || 'unknown';

  // args.id is already "wu-706", don't double-prepend "wu-"
  const idK = args.id.toLowerCase();

  const laneBranch = `lane/${laneK}/${idK}`;
  const worktreePath = path.join('worktrees', `${laneK}-${idK}`);

  console.log(`[wu-cleanup] Cleaning up ${args.id} (${wu.title})`);
  console.log(`[wu-cleanup] Lane: ${wu.lane}`);
  console.log(`[wu-cleanup] Branch: ${laneBranch}`);
  console.log(`[wu-cleanup] Worktree: ${worktreePath}`);
  console.log();

  // WU-2278: Validate worktree ownership before cleanup
  // Prevents cross-agent worktree deletion
  const ownershipResult = validateWorktreeOwnership({ worktreePath, wuId: id });
  if (!ownershipResult.valid) {
    console.error();
    console.error(BOX.TOP);
    console.error('║  OWNERSHIP VALIDATION FAILED');
    console.error(BOX.MID);
    console.error(`║  ${ownershipResult.error}`);
    console.error('║');
    console.error("║  This prevents accidentally deleting another agent's worktree.");
    console.error(BOX.BOT);
    process.exit(EXIT_CODES.ERROR);
  }

  // 1. Verify PR is merged
  console.log('[wu-cleanup] Verifying PR merge status...');
  const { merged, method } = await verifyPRMerged(laneBranch);

  if (!merged) {
    console.error();
    console.error(BOX.TOP);
    console.error('║  PR NOT MERGED');
    console.error(BOX.MID);
    console.error(`║  Branch ${laneBranch} has not been merged to main yet.`);
    console.error('║');
    console.error('║  Next steps:');
    console.error('║  1. Review the PR in GitHub UI');
    console.error('║  2. Merge the PR');
    console.error(`║  3. Re-run: pnpm wu:cleanup --id ${args.id}`);
    console.error(BOX.BOT);
    process.exit(EXIT_CODES.ERROR);
  }

  console.log(`[wu-cleanup] ✓ PR merged (verified via ${method})`);
  console.log();

  // 2. Remove worktree
  await removeWorktree(worktreePath);
  console.log();

  // 3. Delete branch (local + remote)
  await deleteBranch(laneBranch);
  console.log();

  console.log(BOX.TOP);
  console.log('║  CLEANUP COMPLETE');
  console.log(BOX.MID);
  console.log(`║  WU: ${args.id}`);
  console.log('║  Worktree removed');
  console.log('║  Branch deleted (local + remote)');
  console.log(BOX.BOT);
}

// Guard main() for testability (WU-1366)
import { fileURLToPath } from 'node:url';
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main();
}
