---
name: context-management
description: Session checkpoint patterns, output bypass for large results, when to spawn fresh sub-agents. Use for long-running sessions, context exhaustion, or agent coordination.
version: 1.4.0
source: docs/04-operations/_frameworks/lumenflow/agent/onboarding/agent-invocation-guide.md
source_sections: Context Tiers, Session Management, Wave Orchestration
last_updated: {{DATE}}
allowed-tools: Read, Write, Bash
---

# Context Management Skill

**Source**: `docs/04-operations/_frameworks/lumenflow/agent/onboarding/agent-invocation-guide.md`

Patterns for managing context in long-running AI coding sessions.

## Primary Strategy: Spawn Fresh, Don't Continue

**When approaching context limits, spawn a fresh agent instead of continuing after compaction.**

Context compaction (summarization) causes agents to lose critical rules. The recommended approach from [Anthropic's engineering guidance](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents):

> "An initializer agent that sets up the environment, and a coding agent tasked with **making incremental progress in every session**, while leaving clear artifacts for the next session."

### Mandatory Triggers

Spawn a fresh agent when ANY of these apply:

- Context usage exceeds **80%**
- **50+ tool calls** in current session
- Performance degradation (redundant queries, forgotten context)
- You're about to run `/compact` or `/clear`

### Spawn Fresh Protocol

```bash
# 1. Checkpoint your progress
pnpm mem:checkpoint "Progress: completed X, next: Y" --wu WU-XXX

# 2. Commit and push work
git add -A && git commit -m "checkpoint: progress on X"
git push origin lane/<lane>/wu-xxx

# 3. Generate fresh agent prompt
pnpm wu:spawn --id WU-XXX

# 4. EXIT current session (do NOT continue after compaction)

# 5. Start fresh agent with the generated prompt
```

### Why Not Continue After Compaction?

- Compaction summarizes conversation → rules get lost in summary
- Agent forgets worktree discipline, WU context, constraints
- Recovery mechanisms are complex and vendor-specific
- Prevention (fresh agent) is simpler and more reliable than recovery

**This is not failure—it's disciplined execution.** See [wu-sizing-guide.md](../../../docs/04-operations/_frameworks/lumenflow/wu-sizing-guide.md) for complete sizing thresholds.

---

## Session Checkpoints

Use memory commands to preserve state across context boundaries:

```bash
# Start session tracking
pnpm mem:start --wu WU-123

# Save checkpoint before context-heavy operation
pnpm mem:checkpoint --wu WU-123 --note "Completed step 2, starting API integration"

# Resume after /clear
pnpm mem:ready --wu WU-123  # Shows pending work
pnpm mem:inbox --wu WU-123  # Check signals from other agents
```

### Durable Recovery Pattern (WU-1390/1394)

LumenFlow implements automatic recovery hooks that preserve context across compaction:

**Hook Files** (scaffolded by `lumenflow init --client claude`):

- `.claude/hooks/pre-compact-checkpoint.sh` — PreCompact hook: saves checkpoint + writes recovery file
- `.claude/hooks/session-start-recovery.sh` — SessionStart hook: reads recovery file on compact/resume/clear

**How It Works:**

1. **Before compaction**: PreCompact hook writes `.lumenflow/state/recovery-pending-WU-XXX.md`
2. **After session start**: SessionStart hook reads + displays recovery context, then deletes the file
3. **Recovery file persists** through compaction — this is the durable part

**Manual Recovery:**

```bash
# Generate recovery context manually (if hooks didn't fire)
pnpm mem:recover --wu WU-XXX

# Generate spawn prompt with full context
pnpm wu:spawn --id WU-XXX
```

**Important**: The recovery hooks are a safety net. The recommended approach is still to spawn
a fresh agent before compaction rather than relying on post-compaction recovery.

## Output Bypass Pattern

For large results that would exhaust context:

```typescript
// ❌ BAD: Returns 10MB of data into context
const allLogs = await fetchAllLogs();
return allLogs;

// ✅ GOOD: Store to filesystem, return reference
const allLogs = await fetchAllLogs();
await writeFile('/tmp/analysis-results.json', JSON.stringify(allLogs));
console.log('Results saved to /tmp/analysis-results.json');
return { resultPath: '/tmp/analysis-results.json', summary: summarize(allLogs) };
```

## When to Spawn Sub-Agents

Spawn fresh agent when:

- Current context >80% exhausted
- Task is independent and parallelizable
- Need specialized agent (e.g., code-reviewer, test-engineer)
- Switching to different WU scope

Keep in current context when:

- Tasks share significant state
- Sequential dependencies exist
- Context usage still low

## Wave Orchestration Pattern

When orchestrating multi-wave initiatives, use the checkpoint-per-wave pattern to prevent context exhaustion:

```bash
# Spawn next wave then exit (no polling)
pnpm orchestrate:initiative -i INIT-009 -c

# Check progress via stamps
pnpm orchestrate:initiative -i INIT-009 -p

# Repeat for next wave when complete
pnpm orchestrate:initiative -i INIT-009 -c
```

**Key principles:**

1. **Exit immediately after spawning** — No polling loops in the orchestrator
2. **Wave manifests for idempotency** — `.lumenflow/artifacts/waves/INIT-XXX-wave-N.json`
3. **Stamp-based completion** — Check `.lumenflow/stamps/WU-*.done` for progress
4. **Compact output** — Keep orchestrator output under 20 lines

See [orchestration skill](../orchestration/SKILL.md) for complete documentation.

## Context Loading Order

Always load context in this order for best comprehension:

1. `LUMENFLOW.md` — Workflow fundamentals
2. `README.md` — Project structure
3. `lumenflow-complete.md` §§1-7 — Constraints
4. WU YAML — Current task spec
5. Task instructions — What to do
6. Constraints block — Critical rules (at END per "Lost in Middle" research)

## Integration with Other Skills

- **multi-agent-coordination**: For parallel sub-agent work
- **wu-lifecycle**: Session ties to WU lifecycle
- **orchestration**: Agent selection guidance, wave orchestration pattern
- **execution-memory**: Memory layer commands for checkpoints and signals

## Version History

- **v1.3.0** ({{DATE}}): Added pre-clear checkpoint hook guidance
- **v1.1.0** ({{DATE}}): Added wave orchestration pattern cross-reference
- **v1.0.0** ({{DATE}}): Initial skill created
